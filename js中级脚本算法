js中级脚本算法

摘要： 区间求值算法 function sumAll(arr) { var sum =0; if(arr[0]<=arr[1]){ for(var i=arr[0];i<=arr[1];i++){ sum = sum + i; } }else{ for(var i=arr[1];i<=arr[0];i++){ sum = sum + i; } } return sum; } sumAll([1, 4]); 传递给你一个包含两个数字的数组。
区间求值算法
function sumAll(arr) {
  var sum =0;
  if(arr[0]<=arr[1]){
    for(var i=arr[0];i<=arr[1];i++){
      sum = sum + i;
    }    
  }else{
      for(var i=arr[1];i<=arr[0];i++){
        sum = sum + i;
      }
    }
return sum;
}

sumAll([1, 4]);

传递给你一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。最小的数字并非总在最前面
找出数组间差异算法
function diff(arr1, arr2) {
    var newArr = [];
     var lena =  arr1.length;
     var lenb = arr2.length; 
    for(var i = lena;i >= 0;i--){
         for(var j = lenb;j >= 0;j--){
                if(arr1[i] == arr2[j]){
                    arr1.splice(i,1);
                     arr2.splice(j,1);     
             }
         }
    }
    newArr = arr1.concat(arr2);
    return newArr;
}
diff([1, 2, 3, 5], [1, 2, 3, 4, 5]);

比较两个数组，然后返回一个新数组，该数组的元素为两个给定数组中所有独有的数组元素。换言之，返回两个数组的差异
数字转罗马数字
function convert(num) { 
     var nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1];  
    var romans =["m","cm","d","cd","c","xc","l","xl","x","ix","v","iv","i"];  
    var str = '';  
    nums.forEach(function(item,index,array){   //forEach方法中的function回调支持3个参数，第1个是遍历的数组内容；第2个是对应的数组索引，第3个是数组本身
        while(num >= item){  
            str += romans[index];  
            num -= item;  
        }  
     });  
    return str.toUpperCase();  
}  
convert(36); 

将给定的数字转换成罗马数字。所有返回的 罗马数字 都应该是大写形式
对象搜索算法
function where(collection, source) {
    var arr = [];
    var porp=Object.keys(source);   //Object.keys()方法返回一个数组传入对象，返回属性名
    arr=collection.filter(function(obj){
        for(var i=0; i<porp.length; i++){
            if(obj[porp[i]]!==source[porp[i]]){  //判断参数1中各个对象的porp属性的值是否与参数二中的porp属性值相等
                return false;
            }
        }
         return true;
    });  
    return arr;
}
where([{ first: "Romeo", last: "Montague",a:"aaa" }, { first: "Mercutio", last: null,b:"bbb" }, { first: "Tybalt", last: "Capulet",d:"ddd",c:"ccc" }], { last: "Capulet", c:"ccc"});

写一个 function遍历一个对象数组（第一个参数）并返回一个包含相匹配的属性-值对（第二个参数）的所有对象的数组。如果返回的数组中包含 source 对象的属性-值对，那么此对象的每一个属性-值对都必须存在于 collection 的对象中。
例如，如果第一个参数是 [{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }]，第二个参数是 { last: "Capulet" }，那么你必须从数组（第一个参数）返回其中的第三个对象，因为它包含了作为第二个参数传递的属性-值对
查询替换算法
function myReplace(str, before, after) {  
    var len = before.length;
    if(before.charAt(0)>'A' && before.charAt(0)<'Z'){
        after = after.charAt(0).toUpperCase()+after.slice(1);
     }else{
        after = after.toLowerCase();
    }
    str = str.replace(before,after);
    return str;
}
myReplace("A quick brown fox jumped over the lazy dog", "jumped", "Leaped");

使用给定的参数对句子执行一次查找和替换，然后返回新句子。
第一个参数是将要对其执行查找和替换的句子。
第二个参数是将被替换掉的单词（替换前的单词）。
第三个参数用于替换第二个参数（替换后的单词）。
注意：替换时保持原单词的大小写。例如，如果你想用单词 "dog" 替换单词 "Book" ，你应该替换成 "Dog"。
字符串移动插入算法
function translate(str) {
    var vowel = [ "a","e","i","o","u"];
    if(vowel.indexOf(str[0]) != -1){
        return str+"way";
    }
    while(vowel.indexOf(str[0]) == -1){
        str = str.substr(1)+str.substr(0,1);
    }
    return str+"ay";
}
translate("bconsonant");

把指定的字符串翻译成 pig latin。即把一个英文单词的第一个辅音或辅音丛（consonant cluster）移到词尾，然后加上后缀 "ay"。如果单词以元音开始，你只需要在词尾添加 "way" 就可以了
字符配对算法
function pair(str) {  
    var o = {
         'G':'C',
         'C':'G',
         'A':'T',
         'T':'A'
    };
    return str.split('').map((cur) => {
        return [cur,o[cur]];
    })
}
pair("TCG");

DNA 链缺少配对的碱基。依据每一个碱基，为其找到配对的碱基，然后将结果作为第二个数组返回。Base pairs（碱基对） 是一对 AT 和 CG，为给定的字母匹配缺失的碱基。在每一个数组中将给定的字母作为第一个碱基返回。
例如，对于输入的 GCG，相应地返回 [["G", "C"], ["C","G"],["G", "C"]]。字母和与之配对的字母在一个数组内，然后所有数组再被组织起来封装进一个数组。
字符串查询补充算法
function fearNotLetter(str) {
    var arr=[];
    var len = str.length;
    for(var i=0;i<len-1;i++){
        var n = str[i+1].charCodeAt() - str[i].charCodeAt();
         if( n >1 ){
            for(var j = 1;j < n;j++){
                arr.push( String.fromCharCode(str[i].charCodeAt()+j) );
            }
        }
    }
    return arr || undefined;
}
fearNotLetter("acg");

从传递进来的字母序列中找到缺失的字母并返回它。如果所有字母都在序列中，返回 undefined
输入检查算法
function boo(bool) {
    return bool === Boolean(bool);  
}
boo(null);

检查一个值是否是基本布尔类型，并返回 true 或 false。基本布尔类型即 true 和 false
数组去重算法
function unite(arr1, arr2, arr3) {
    var args = Array.from(arguments);  //Array.from() 方法从一个类似数组或可迭代的对象中创建一个新的数组实例
    var arr = args.reduce(function(prev,cur,index,array){
        return prev.concat(cur);
    });
    return arr.filter(function(item,index,array){
        return array.indexOf(item) === index; //indexOf()方法返回在该数组中第一个找到的元素位置，如果它不存在则返回-1
    });
}
unite([1, 3, 2], [5, 2, 1, 4], [2, 1,5]);

写一个 function，传入两个或两个以上的数组，返回一个以给定的原始数组排序的不包含重复值的新数组。换句话说，所有数组中的所有值都应该以原始顺序被包含在内，但是在最终的数组中不包含重复值。非重复的数字应该以它们原始的顺序排序，但最终的数组不应该以数字顺序排序。
html符号转实体算法
function convert(str) {
    str=str.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;");  
    return str;   
}
convert("Hamburgers < Pizza & Tacos")

将字符串中的字符 &、<、>、" （双引号）, 以及 ' （单引号）转换为它们对应的 HTML 实体
字符串连接算法
function spinalCase(str) {
    var len=str.length;
    for(var i=0;i<len;i++){
        if( str.charCodeAt(i+1)>=65 && str.charCodeAt(i+1)<=90 && str.charCodeAt(i)>=97 && str.charCodeAt(i)<=122 ){
            str = str.replace(str[i+1],' '+str[i+1]);
        }
    }
    str = str.toLowerCase().replace(/_| /g,'-')
     return str;
}
spinalCase("thisIsSpinalTap");

将字符串转换为 spinal case。Spinal case 是 all-lowercase-words-joined-by-dashes 这种形式的，也就是以连字符连接所有小写单词
斐波纳契奇数求和算法
function sumFibs(num) {
    var arr=[1,1];
    for(var i=0;i<num;i++){
        arr[i+2] = arr[i]+arr[i+1];
        if(arr[i+2]>num){
        break;
    }
  }
  arr = arr.filter(function(n){
     if(n%2 === 0){
        return false;
    }
    return true;
  });
  var result = arr.reduce(function(a,b){
    return a+b;
  });
  return result;  
}  
sumFibs(9);

给一个正整数num，返回小于或等于num的斐波纳契奇数之和。斐波纳契数列中的前几个数字是 1、1、2、3、5 和 8，随后的每一个数字都是前两个数字之和。
例如，sumFibs(4)应该返回 5，因为斐波纳契数列中所有小于4的奇数是 1、1、3。
提示：此题不能用递归来实现斐波纳契数列。因为当num较大时，内存会溢出，推荐用数组来实现
质素求和算法
function sumPrimes(num) {
    var arr = [];
    var isTrue = false;
    var sum = 0;
    var i = 2;
    while(i <= num){
        for(var j=2;j<i;j++){
            if(i%j == 0){
                isTrue = true;
                    break;
            }
        }
        if(!isTrue){
            arr.push(i);
        }
        i++;
         isTrue = false;
    }
    for(var k =0;k<arr.length;k++){
         sum = sum + arr[k];
    }
     return sum;
}
sumPrimes(10);

求小于等于给定数值的质数之和。只有 1 和它本身两个约数的数叫质数。例如，2 是质数，因为它只能被 1 和 2 整除。1 不是质数，因为它只能被自身整除。给定的数不一定是质数
最小公倍数算法
function smallestCommons(arr) {
    arr=arr.sort(function(a,b){
        return a-b;
    });
    function fun(m,n){
        if(m%n===0) return n;
        return fun(n,m%n);
    }
    var num=arr[0];
    for(var i=arr[0]+1;i<=arr[1];i++){
        num*=i/fun(num,i);
    }
    return num;
}
smallestCommons([1,5]);

找出能被两个给定参数和它们之间的连续数字整除的最小公倍数。范围是两个数字构成的数组，两个数字不一定按数字顺序排序。
例如对 1 和 3 —— 找出能被 1 和 3 和它们之间所有数字整除的最小公倍数
数组验证算法
function find(arr, func) {
    arr2=arr.filter(func);
    return arr2[0]; 
}
find([1, 2, 3, 4], function(num){ return num % 2 === 0; });

写一个 function，它浏览数组（第一个参数）并返回数组中第一个通过某种方法（第二个参数）验证的元素
数组取值算法
function drop(arr, func) {
    var arr2 = arr.filter(func);
    if(arr2.length == 0){
        return arr2;
    }else{
        var start = arr.indexOf(arr2[0]);
        arr.splice(0,start);
        return arr;
    }
}
drop([1, 4, 2, 3], function(n) {return n < 3; });

丢弃数组(arr)的元素，从左边开始，直到回调函数return true就停止。第二个参数，func，是一个函数。用来测试数组的第一个元素，如果返回fasle，就从数组中抛出该元素(注意：此时数组已被改变)，继续测试数组的第一个元素，如果返回fasle，继续抛出，直到返回true。最后返回数组的剩余部分，如果没有剩余，就返回一个空数组
数组简化算法
function steamroller(arr) {
    var result = [];
    for(var i=0;i<arr.length;i++){
        if(Array.isArray(arr[i])){
            result = result.concat(steamroller(arr[i]));
        }else{
            result.push(arr[i]);
        }
    }
    return result;
}
steamroller([1, [2], [3, [[4],6]]]);

对嵌套的数组进行扁平化处理。你必须考虑到不同层级的嵌套
二进制转字符算法
function binaryAgent(str) {
    var arr=str.split(' ');
    var len = arr.length;
    for(var i=0;i<len;i++){
        var charCode = String.fromCharCode( parseInt(arr[i],2) );
        arr.splice(i,1,charCode);
    }
     return arr.join('');
}
binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");

传入二进制字符串，翻译成英语句子并返回。二进制字符串是以空格分隔的
数组元素判断算法
function every(collection, pre) {
    var bCheck = true;
    for(var i in collection){
        if(!collection[i][pre]){
            bCheck = false;
        }
    }
    return bCheck;
}
every([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex");

完善编辑器中的every函数，如果集合(collection)中的所有对象都存在对应的属性(pre)，并且属性(pre)对应的值为真。函数返回ture。反之，返回false。
记住：只能通过中括号来访问对象的变量属性(pre)。
提示：可以有多种实现方式，最简洁的方式莫过于Array.prototype.every()
函数迭代可选参数算法
function add() {
    var a=0;
    if(typeof arguments[0] !== "number" || (arguments.length > 1 && typeof arguments[1] !== "number")){
        return undefined;
    }
    if(arguments.length == 1){
        var arg0 = arguments[0];
        return function(num){
            if(typeof num !== "number"){
                return undefined;
            }
            return arg0 + num;
        };
    }else{
        return arguments[0] + arguments[1];
    }
}
add(2,6,3);

创建一个计算两个参数之和的 function。如果只有一个参数，则返回一个 function，该 function 请求一个参数然后返回求和的结果。
例如，add(2, 3) 应该返回 5，而 add(2) 应该返回一个 function。
调用这个有一个参数的返回的 function，返回求和的结果：
var sumTwoAnd = add(2);
sumTwoAnd(3) 返回 5。
如果两个参数都不是有效的数字，则返回 undefined
